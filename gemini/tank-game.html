<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>å¦å…‹å¤§æˆ˜ FC å¢å¼ºç‰ˆ</title>
    <style>
        body {
            background-color: #333;
            color: #eee;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: 'Press Start 2P', monospace, sans-serif; /* å‡è£…æ˜¯åƒç´ å­—ä½“ */
            user-select: none;
        }
        canvas {
            background-color: #000;
            border: 8px solid #777;
            image-rendering: pixelated; /* åƒç´ åŒ–æ¸²æŸ“ */
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }
        .hud {
            margin-top: 10px;
            display: flex;
            gap: 20px;
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
        }
        .controls {
            margin-top: 15px;
            font-size: 12px;
            color: #aaa;
        }
        .label { color: #e74c3c; }
        .val { color: #fff; }
    </style>
</head>
<body>

    <canvas id="gameCanvas" width="520" height="520"></canvas>
    
    <div class="hud">
        <div><span class="label">Enemy:</span> <span class="val" id="uiEnemy">20</span></div>
        <div><span class="label">Score:</span> <span class="val" id="uiScore">0</span></div>
        <div><span class="label">Level:</span> <span class="val" id="uiLevel">1</span></div>
    </div>

    <div class="controls">
        WASDç§»åŠ¨ | SPACEå°„å‡» | Pæš‚åœ
    </div>

<script>
/**
 * å¦å…‹å¤§æˆ˜å¢å¼ºç‰ˆ - å•æ–‡ä»¶ HTML5 å®ç°
 * åŒ…å«ï¼šåƒç´ ç»˜å›¾å¼•æ“ã€ç²’å­çˆ†ç‚¸ã€é“å…·ç³»ç»Ÿã€AIè¡Œä¸º
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- æ¸¸æˆé…ç½® ---
const CELL_SIZE = 40; // æ ¼å­å¤§å°
const GRID_SIZE = 13; // åœ°å›¾ 13x13
const GAME_WIDTH = CELL_SIZE * GRID_SIZE;
const GAME_HEIGHT = CELL_SIZE * GRID_SIZE;

const DIR = { UP: 0, RIGHT: 1, DOWN: 2, LEFT: 3 };
const TYPES = { BASIC: 0, FAST: 1, ARMOR: 2 }; // æ•Œäººç±»å‹

// --- èµ„æºç»˜åˆ¶å™¨ (ç”¨ä»£ç ç”»åƒç´ å›¾) ---
const Drawer = {
    rect: (x, y, w, h, c) => { ctx.fillStyle = c; ctx.fillRect(x, y, w, h); },
    
    // ç”»å¦å…‹ (ç”»å‡ºå±¥å¸¦ã€è½¦èº«ã€ç‚®ç®¡)
    tank: (x, y, dir, color, frame) => {
        ctx.save();
        ctx.translate(x + 16, y + 16); // ç§»åŠ¨ä¸­å¿ƒç‚¹ (å¦å…‹çº¦32x32)
        // æ—‹è½¬
        if (dir === DIR.RIGHT) ctx.rotate(Math.PI / 2);
        if (dir === DIR.DOWN) ctx.rotate(Math.PI);
        if (dir === DIR.LEFT) ctx.rotate(-Math.PI / 2);

        // å±¥å¸¦ (å¸¦åŠ¨ç”»)
        ctx.fillStyle = "#000"; // å±¥å¸¦åº•è‰²
        ctx.fillRect(-15, -15, 30, 30);
        
        ctx.fillStyle = color; // ä¸»è‰²
        // å·¦å±¥å¸¦
        ctx.fillRect(-15, -14, 8, 28);
        // å³å±¥å¸¦
        ctx.fillRect(7, -14, 8, 28);
        
        // å±¥å¸¦ç»†èŠ‚ (è½®å­æ»šåŠ¨æ•ˆæœ)
        ctx.fillStyle = "#000";
        let offset = frame ? 2 : 0;
        for(let i=0; i<6; i++) {
            ctx.fillRect(-15, -14 + i*4 + offset, 8, 2);
            ctx.fillRect(7, -14 + i*4 + offset, 8, 2);
        }

        // è½¦èº«
        ctx.fillStyle = color;
        ctx.fillRect(-8, -10, 16, 22); // ä¸»ä½“
        
        // ç›–å­/è£…é¥°
        ctx.fillStyle = adjustColor(color, -40); // æ·±è‰²é˜´å½±
        ctx.fillRect(-5, -6, 10, 10);

        // ç‚®ç®¡
        ctx.fillStyle = "#ccc"; // é“¶è‰²ç‚®ç®¡
        ctx.fillRect(-2, -20, 4, 16);
        ctx.fillStyle = "#fff"; // ç‚®å£é«˜å…‰
        ctx.fillRect(-2, -20, 4, 4);

        ctx.restore();
    },

    // ç”»ç –å¢™ (å¸¦ç –ç¼)
    brick: (x, y) => {
        ctx.fillStyle = "#a52a2a"; // ç –çº¢
        ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
        ctx.fillStyle = "#dcdcdc"; // æ°´æ³¥ç¼
        ctx.fillRect(x, y + 10, CELL_SIZE, 2);
        ctx.fillRect(x, y + 20, CELL_SIZE, 2);
        ctx.fillRect(x, y + 30, CELL_SIZE, 2);
        // ç«–ç¼
        ctx.fillRect(x + 20, y, 2, 10);
        ctx.fillRect(x + 10, y + 10, 2, 10);
        ctx.fillRect(x + 20, y + 20, 2, 10);
        ctx.fillRect(x + 10, y + 30, 2, 10);
    },

    // ç”»é“å¢™
    steel: (x, y) => {
        ctx.fillStyle = "#bdc3c7"; // é“¶ç°
        ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
        ctx.fillStyle = "#fff";
        ctx.fillRect(x + 8, y + 8, CELL_SIZE - 16, CELL_SIZE - 16); // å†…éƒ¨é«˜å…‰
        ctx.fillStyle = "#bdc3c7";
        ctx.fillRect(x + 16, y + 16, CELL_SIZE - 32, CELL_SIZE - 32); // ä¸­å¿ƒ
    },

    // ç”»è€é¹°
    base: (x, y, dead) => {
        if (dead) {
            ctx.fillStyle = "#333";
            ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
            ctx.fillStyle = "red"; // åºŸå¢Ÿ
            ctx.fillText("â˜ ï¸", x+5, y+30);
        } else {
            ctx.fillStyle = "#000";
            ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
            // ç®€å•çš„é¹°å¾½ç« 
            ctx.fillStyle = "#e67e22"; // é‡‘è‰²
            ctx.beginPath();
            ctx.moveTo(x + 20, y + 5);
            ctx.lineTo(x + 35, y + 35);
            ctx.lineTo(x + 5, y + 35);
            ctx.fill();
            ctx.fillStyle = "#ecf0f1"; // ç¿…è†€ç™½
            ctx.fillRect(x + 5, y + 15, 30, 5);
        }
    },

    // ç”»é“å…·
    item: (x, y, type) => {
        let pulse = Math.sin(Date.now() / 100) * 5; // é—ªçƒæ•ˆæœ
        ctx.fillStyle = `rgb(${255}, ${255-pulse*10}, ${255-pulse*10})`;
        ctx.fillRect(x, y, 32, 32);
        ctx.fillStyle = "#000";
        ctx.font = "20px bold monospace";
        ctx.fillText(type === 'star' ? "â˜…" : "ğŸ’£", x + 5, y + 24);
        ctx.strokeStyle = "#f00";
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, 32, 32);
    }
};

// é¢œè‰²è¾…åŠ©
function adjustColor(color, amount) {
    return color; // ç®€åŒ–ç‰ˆæœ¬ï¼Œå®é™…å¯åšHEXè§£æå˜æš—
}

// --- æ¸¸æˆç±» ---

class GameObject {
    constructor(x, y, w, h) {
        this.x = x; this.y = y; this.w = w; this.h = h;
        this.delete = false;
    }
    collide(o) {
        return this.x < o.x + o.w && this.x + this.w > o.x &&
               this.y < o.y + o.h && this.y + this.h > o.y;
    }
}

class Explosion {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.timer = 10; // æŒç»­å¸§æ•°
    }
    update() { this.timer--; }
    draw() {
        if (this.timer <= 0) return;
        ctx.fillStyle = this.timer > 5 ? "#ff0" : "#f00";
        let r = (10 - this.timer) * 3;
        ctx.beginPath();
        ctx.arc(this.x, this.y, r, 0, Math.PI*2);
        ctx.fill();
        
        // çˆ†ç‚¸å¤–åœˆ
        ctx.strokeStyle = "white";
        ctx.beginPath();
        ctx.arc(this.x, this.y, r + 5, 0, Math.PI*2);
        ctx.stroke();
    }
}

class Bullet extends GameObject {
    constructor(x, y, dir, owner, speed = 5) {
        super(x, y, 6, 6); // å­å¼¹å˜å°ç‚¹
        // ä¿®æ­£å‡ºç”Ÿä½ç½®åˆ°å¦å…‹ç‚®å£
        if(dir === DIR.UP) { this.x += 13; this.y -= 5; }
        if(dir === DIR.DOWN) { this.x += 13; this.y += 32; }
        if(dir === DIR.LEFT) { this.x -= 5; this.y += 13; }
        if(dir === DIR.RIGHT) { this.x += 32; this.y += 13; }
        
        this.dir = dir;
        this.owner = owner;
        this.speed = speed;
    }
    update() {
        if (this.dir === DIR.UP) this.y -= this.speed;
        if (this.dir === DIR.DOWN) this.y += this.speed;
        if (this.dir === DIR.LEFT) this.x -= this.speed;
        if (this.dir === DIR.RIGHT) this.x += this.speed;

        // è¾¹ç•Œ
        if (this.x < 0 || this.x > GAME_WIDTH || this.y < 0 || this.y > GAME_HEIGHT) this.delete = true;
        
        // æ’å¢™æ£€æµ‹
        this.checkMapCollision();
    }
    checkMapCollision() {
        let r = Math.floor((this.y + 3) / CELL_SIZE);
        let c = Math.floor((this.x + 3) / CELL_SIZE);
        if (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE) {
            let tile = game.map[r][c];
            if (tile === 1) { // ç –
                game.map[r][c] = 0; // æ¯å
                this.delete = true;
                game.explosions.push(new Explosion(this.x, this.y));
            } else if (tile === 2) { // é“
                this.delete = true;
                game.explosions.push(new Explosion(this.x, this.y)); // åªå‡ºç«èŠ±
            } else if (tile === 9) { // åŸºåœ°
                game.map[r][c] = 0;
                this.delete = true;
                game.endGame(false);
            }
        }
    }
    draw() {
        ctx.fillStyle = "#fff";
        ctx.fillRect(this.x, this.y, this.w, this.h);
    }
}

class Tank extends GameObject {
    constructor(x, y, type) {
        super(x, y, 32, 32); // å¦å…‹32x32, æ ¼å­40x40ï¼Œç•™ç©ºéš™
        this.type = type; // 'player' or Enemy Type
        this.dir = DIR.UP;
        this.speed = 2;
        this.color = "#fabd2f";
        this.cooldown = 0;
        this.frame = 0; // åŠ¨ç”»å¸§
        this.isMoving = false;
        
        // å±æ€§è®¾ç½®
        if (type === TYPES.FAST) { this.color = "#2ecc71"; this.speed = 3.5; }
        if (type === TYPES.ARMOR) { this.color = "#e74c3c"; this.speed = 1.5; this.hp = 2; }
        if (type === TYPES.BASIC) { this.color = "#bdc3c7"; }
        if (type === 'player') { this.hp = 1; }
        else { this.hp = type === TYPES.ARMOR ? 2 : 1; }
        
        // æ‰å®å±æ€§
        this.hasItem = (type !== 'player' && Math.random() < 0.2); // 20%å‡ ç‡çº¢å¦å…‹
    }

    move(dir) {
        this.dir = dir;
        this.isMoving = true;
        let nx = this.x, ny = this.y;
        if (dir === DIR.UP) ny -= this.speed;
        if (dir === DIR.DOWN) ny += this.speed;
        if (dir === DIR.LEFT) nx -= this.speed;
        if (dir === DIR.RIGHT) nx += this.speed;

        // ç¢°æ’ç›’ç¼©å°ä¸€ç‚¹ï¼Œé˜²æ­¢å¡å¢™
        if (!this.checkCollision(nx, ny)) {
            this.x = nx; this.y = ny;
            if (game.frames % 5 === 0) this.frame = !this.frame;
        }
    }

    checkCollision(nx, ny) {
        // 1. è¾¹ç•Œ
        if (nx < 0 || nx + this.w > GAME_WIDTH || ny < 0 || ny + this.h > GAME_HEIGHT) return true;
        
        // 2. åœ°å›¾å—
        let corners = [
            {r: Math.floor(ny/CELL_SIZE), c: Math.floor(nx/CELL_SIZE)},
            {r: Math.floor((ny+this.h-1)/CELL_SIZE), c: Math.floor(nx/CELL_SIZE)},
            {r: Math.floor(ny/CELL_SIZE), c: Math.floor((nx+this.w-1)/CELL_SIZE)},
            {r: Math.floor((ny+this.h-1)/CELL_SIZE), c: Math.floor((nx+this.w-1)/CELL_SIZE)}
        ];
        for(let p of corners) {
            if (p.r >= 0 && p.r < GRID_SIZE && p.c >=0 && p.c < GRID_SIZE) {
                if (game.map[p.r][p.c] !== 0) return true;
            }
        }
        
        // 3. å¦å…‹äº’æ–¥ (ç®€åŒ–)
        // ...ç•¥ï¼Œä¸ºäº†ä»£ç çŸ­æš‚æ—¶å¿½ç•¥å¦å…‹äº’ç›¸æ¨æŒ¤çš„å¤æ‚ç‰©ç†
        return false;
    }

    shoot() {
        if (this.cooldown > 0) return;
        game.bullets.push(new Bullet(this.x, this.y, this.dir, this.type === 'player' ? 'player' : 'enemy', this.bulletSpeed || 5));
        this.cooldown = 20;
    }

    update() {
        if (this.cooldown > 0) this.cooldown--;
        
        // AI é€»è¾‘
        if (this.type !== 'player') {
            // ç®€å•çš„ AI
            if (Math.random() < 0.02 || !this.isMoving) {
                // æ¢æ–¹å‘
                const dirs = [DIR.UP, DIR.DOWN, DIR.LEFT, DIR.RIGHT];
                // ç¨å¾®æ™ºèƒ½ä¸€ç‚¹ï¼š20%å‡ ç‡æœå‘ç©å®¶
                if (Math.random() < 0.2 && game.player) {
                     if (Math.abs(game.player.x - this.x) > Math.abs(game.player.y - this.y)) {
                         this.dir = game.player.x < this.x ? DIR.LEFT : DIR.RIGHT;
                     } else {
                         this.dir = game.player.y < this.y ? DIR.UP : DIR.DOWN;
                     }
                } else {
                    this.dir = dirs[Math.floor(Math.random() * 4)];
                }
            }
            
            // å°è¯•ç§»åŠ¨
            let oldX = this.x, oldY = this.y;
            this.move(this.dir);
            if (this.x === oldX && this.y === oldY) this.isMoving = false; // æ’å¢™äº†

            // å°„å‡»
            if (Math.random() < 0.03) this.shoot();
        }
    }

    draw() {
        let drawColor = this.color;
        // çº¢å¦å…‹é—ªçƒ
        if (this.hasItem) drawColor = (Math.floor(Date.now() / 200) % 2 === 0) ? "#f00" : "#fff";
        
        Drawer.tank(this.x, this.y, this.dir, drawColor, this.frame);
        
        // è¡€é‡æ˜¾ç¤º (å¦‚æœæ˜¯é‡ç”²)
        if (this.hp > 1) {
            ctx.fillStyle = "yellow";
            ctx.fillRect(this.x, this.y - 5, this.w * (this.hp/2), 3);
        }
    }
}

class Item extends GameObject {
    constructor(x, y, type) {
        super(x, y, 32, 32);
        this.type = type; // 'star', 'bomb'
    }
    draw() { Drawer.item(this.x, this.y, this.type); }
}

// --- æ¸¸æˆä¸»æ§ ---

const game = {
    canvas: canvas,
    ctx: ctx,
    map: [],
    player: null,
    enemies: [],
    bullets: [],
    items: [],
    explosions: [],
    frames: 0,
    score: 0,
    level: 1,
    enemyRemaining: 20,
    spawnTimer: 0,
    isOver: false,
    isPaused: false,

    init() {
        // åœ°å›¾æ•°æ® (1=ç –, 2=é“, 9=åŸºåœ°)
        const m = [
            [0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,1,0,1,0,1,0,1,0,1,0,1,0],
            [0,1,0,1,0,1,0,1,0,1,0,1,0],
            [0,1,0,1,0,1,2,1,0,1,0,1,0],
            [0,1,0,1,0,0,0,0,0,1,0,1,0],
            [0,0,0,0,0,2,2,2,0,0,0,0,0], // ä¸­é—´ç¨å¾®ç©ºæ—·ç‚¹
            [0,1,0,1,0,0,0,0,0,1,0,1,0],
            [0,1,0,1,0,1,2,1,0,1,0,1,0],
            [0,0,0,0,0,1,0,1,0,0,0,0,0],
            [0,1,0,1,0,1,0,1,0,1,0,1,0],
            [0,1,0,1,0,0,0,0,0,1,0,1,0],
            [0,1,0,0,0,1,1,1,0,0,0,1,0],
            [0,0,0,0,0,1,9,1,0,0,0,0,0]
        ];
        this.map = JSON.parse(JSON.stringify(m));
        this.player = new Tank(4 * CELL_SIZE + 4, 12 * CELL_SIZE + 4, 'player');
        
        this.enemies = [];
        this.bullets = [];
        this.explosions = [];
        this.items = [];
        this.enemyRemaining = 20;
        this.score = 0;
        this.isOver = false;
        this.loop();
    },

    spawnEnemy() {
        if (this.enemyRemaining <= 0) return;
        if (this.enemies.length >= 4) return; // å±å¹•æœ€å¤š4ä¸ª

        let spawnX = [0, 6, 12][Math.floor(Math.random()*3)] * CELL_SIZE;
        
        // éšæœºç±»å‹
        let r = Math.random();
        let type = TYPES.BASIC;
        if (r > 0.7) type = TYPES.FAST;
        if (r > 0.9) type = TYPES.ARMOR;

        this.enemies.push(new Tank(spawnX + 4, 4, type));
        this.enemyRemaining--;
    },

    update() {
        if (this.isOver || this.isPaused) return;
        this.frames++;

        // ç”Ÿæˆæ•Œäºº
        if (this.frames % 100 === 0) this.spawnEnemy();

        // ç©å®¶
        if (keys['w']) this.player.move(DIR.UP);
        else if (keys['s']) this.player.move(DIR.DOWN);
        else if (keys['a']) this.player.move(DIR.LEFT);
        else if (keys['d']) this.player.move(DIR.RIGHT);
        else this.player.isMoving = false;
        
        if (keys[' ']) this.player.shoot();
        this.player.update();

        // å®ä½“æ›´æ–°
        this.enemies.forEach(e => e.update());
        this.bullets.forEach(b => b.update());
        this.explosions.forEach(e => e.update());

        // ç¢°æ’é€»è¾‘ï¼šå­å¼¹å‡»ä¸­å¦å…‹
        this.bullets.forEach(b => {
            if (b.delete) return;
            
            // ç©å®¶å­å¼¹ -> æ•Œäºº
            if (b.owner === 'player') {
                this.enemies.forEach(e => {
                    if (b.collide(e)) {
                        b.delete = true;
                        e.hp--;
                        if (e.hp <= 0) {
                            e.delete = true;
                            this.score += 100;
                            this.explosions.push(new Explosion(e.x + 16, e.y + 16));
                            // æ‰é“å…·
                            if (e.hasItem) {
                                this.items.push(new Item(e.x, e.y, Math.random()>0.5 ? 'star' : 'bomb'));
                            }
                        } else {
                            // å‡»ä¸­æ•ˆæœ
                            this.explosions.push(new Explosion(b.x, b.y));
                        }
                    }
                });
            }
            // æ•Œäººå­å¼¹ -> ç©å®¶
            else {
                if (b.collide(this.player)) {
                    b.delete = true;
                    this.player.delete = true;
                    this.endGame(false);
                }
            }
        });

        // ç©å®¶åƒé“å…·
        this.items.forEach(i => {
            if (this.player.collide(i)) {
                i.delete = true;
                if (i.type === 'star') {
                    this.player.bulletSpeed = 10; // åŠ é€Ÿå­å¼¹
                    this.player.cooldown = 0;
                    this.score += 500;
                }
                if (i.type === 'bomb') {
                    this.enemies.forEach(e => {
                        e.delete = true;
                        this.explosions.push(new Explosion(e.x+16, e.y+16));
                    });
                    this.score += 500;
                }
            }
        });

        // æ¸…ç†
        this.enemies = this.enemies.filter(e => !e.delete);
        this.bullets = this.bullets.filter(b => !b.delete);
        this.items = this.items.filter(i => !i.delete);
        this.explosions = this.explosions.filter(e => e.timer > 0);

        // èƒœåˆ©æ£€æµ‹
        if (this.enemyRemaining === 0 && this.enemies.length === 0) this.endGame(true);

        // æ›´æ–°UI
        document.getElementById('uiEnemy').innerText = this.enemyRemaining + this.enemies.length;
        document.getElementById('uiScore').innerText = this.score;
    },

    draw() {
        // æ¸…ç©ºèƒŒæ™¯
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // ç”»åœ°å›¾
        for(let r=0; r<GRID_SIZE; r++) {
            for(let c=0; c<GRID_SIZE; c++) {
                let t = this.map[r][c];
                let x = c * CELL_SIZE, y = r * CELL_SIZE;
                if (t === 1) Drawer.brick(x, y);
                if (t === 2) Drawer.steel(x, y);
                if (t === 9) Drawer.base(x, y, this.isOver && !this.win);
            }
        }

        // ç”»é“å…·
        this.items.forEach(i => i.draw());

        // ç”»å®ä½“
        if (!this.player.delete) this.player.draw();
        this.enemies.forEach(e => e.draw());
        this.bullets.forEach(b => b.draw());
        this.explosions.forEach(e => e.draw());
        
        // æ¸¸æˆç»“æŸè¦†ç›–å±‚
        if (this.isOver) {
            ctx.fillStyle = "rgba(0,0,0,0.7)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#e74c3c";
            ctx.font = "40px 'Courier New'";
            ctx.textAlign = "center";
            ctx.fillText(this.win ? "VICTORY!" : "GAME OVER", canvas.width/2, canvas.height/2);
            ctx.font = "20px 'Courier New'";
            ctx.fillStyle = "#fff";
            ctx.fillText("Press F5 to Restart", canvas.width/2, canvas.height/2 + 40);
        }
    },

    endGame(win) {
        this.isOver = true;
        this.win = win;
    },

    loop() {
        requestAnimationFrame(() => this.loop());
        this.update();
        this.draw();
    }
};

// --- è¾“å…¥æ§åˆ¶ ---
const keys = {};
window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    keys[e.key] = true; // Space capture
    if(e.key.toLowerCase() === 'p') game.isPaused = !game.isPaused;
});
window.addEventListener('keyup', e => {
    keys[e.key.toLowerCase()] = false;
    keys[e.key] = false;
});

// å¯åŠ¨
game.init();

</script>
</body>
</html>